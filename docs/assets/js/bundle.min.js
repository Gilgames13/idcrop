!function(n){function t(I){if(e[I])return e[I].exports;var g=e[I]={i:I,l:!1,exports:{}};return n[I].call(g.exports,g,g.exports,t),g.l=!0,g.exports}var e={};t.m=n,t.c=e,t.d=function(n,e,I){t.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:I})},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},t.p="",t(t.s=1)}([/*!**************************!*\
	!*** ./lib/js/idcrop.js ***!
	\**************************/
  /*! dynamic exports provided */
  /*! all exports used */
  function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nvar IdCrop = function () {\n  "use strict";\n\n  var elements = {},\n      toCrop = {},\n      isDrawing = false,\n      handles = 0,\n      points = [],\n      s = 4;\n\n  var init = function init(displayId, previewId, toolbarId, sides) {\n    s = sides;\n    // Generate the UI.\n    createUI(displayId, previewId, toolbarId);\n    fakeInput(elements.upload, elements.fakeUpload);\n    // File input by clicking event.\n    elements.upload.addEventListener("change", startCroppingArea, false);\n    // File input by dragging event.\n    var draggables = [elements.display, elements.canvas];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = draggables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var draggable = _step.value;\n\n        draggable.addEventListener("dragenter", dragFileEnter, false);\n        draggable.addEventListener("dragover", dragFileOver, false);\n        draggable.addEventListener("dragleave", dragFileLeave, false);\n        draggable.addEventListener("drop", startCroppingArea, false);\n      }\n      // Clear events.\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    window.addEventListener("mouseup", clear, false);\n  };\n\n  var createUI = function createUI(displayId, previewId, toolbarId) {\n    /*\n     * Injects HTML needed for the UI into the user chosen containers.\n     */\n\n    var displayArea = document.querySelector(displayId),\n        previewArea = document.querySelector(previewId),\n        toolbarArea = document.querySelector(toolbarId);\n\n    // Add classes to containers\n    displayArea.classList.add("idwall-display");\n    previewArea.classList.add("idwall-preview");\n\n    var htmlDisplay = "",\n        htmlToolbar = "";\n\n    // Actual cropping container.\n    htmlDisplay += "<canvas id=\'idwall-crop\'></canvas>";\n    htmlDisplay += "<p>Drop files here or ";\n    // Fake button for better style handling of the file input.\n    htmlDisplay += "<a href=\'\' id=\'idwall-upload-fake\'>browse...</a>";\n    htmlDisplay += "</p>";\n    // File input for convenience.\n    htmlToolbar += "<input type=\'file\' name=\'upload\' id=\'idwall-upload\' />";\n    htmlToolbar += "<p id=\'idwall-file-name\'>No file selected.</p>";\n\n    toolbarArea.insertAdjacentHTML("beforeend", htmlToolbar);\n    displayArea.insertAdjacentHTML("beforeend", htmlDisplay);\n\n    // Populate elements JSON, now that they exist.\n    elements = getElements(displayId, previewId, toolbarId);\n  };\n\n  var getElements = function getElements(displayId, previewId, toolbarId) {\n    /*\n     * Generates JSON with all the elements from the injected HTML.\n     */\n\n    return {\n      // Display area.\n      display: document.querySelector(displayId),\n      canvas: document.getElementById("idwall-crop"),\n      hint: document.querySelector(".idwall-display p"),\n      // Upload area.\n      upload: document.getElementById("idwall-upload"),\n      fakeUpload: document.getElementById("idwall-upload-fake"),\n      filename: document.getElementById("idwall-file-name"),\n      // Toolbar area.\n      toolbar: document.querySelector(toolbarId),\n      // Preview crop area.\n      preview: document.querySelector(previewId)\n    };\n  };\n\n  var fakeInput = function fakeInput(input, _fakeInput) {\n    /*\n     * Gets a fake input to answer as if it were the real one.\n     *\n     * @param Node input - the input to be hidden and faked.\n     * @param Node fakeInput - the input that will simulate the hidden one.\n     */\n\n    input.style.display = "none";\n    _fakeInput.addEventListener("click", function (event) {\n      event = event || window.event;\n      event.preventDefault();\n      input.click();\n    });\n  };\n\n  var startCroppingArea = function startCroppingArea(event) {\n    /*\n     * Displays the inputted file and starts the cropping UI.\n     */\n\n    event = event || window.event;\n    event.preventDefault();\n\n    elements.display.classList.remove("hovered");\n    handles = 0;\n\n    // Get the file object and start the reader.\n    var file = typeof event.target.files === "undefined" ? event.dataTransfer.files[0] : event.target.files[0],\n        reader = new FileReader();\n\n    if (typeof file === "undefined") return false;\n\n    elements.filename.innerHTML = file.name;\n\n    // Display the image, hide the label and start listening to click on canvas.\n    reader.onload = function (event) {\n      elements.display.style.backgroundImage = "url(" + event.target.result + ")";\n      elements.hint.style.display = "none";\n      elements.canvas.style.display = "block";\n\n      getBackgroundImageSize().then(function () {\n        elements.canvas.width = toCrop.width;\n        elements.canvas.height = toCrop.height;\n        elements.canvas.style.left = toCrop.left + "px";\n        elements.canvas.style.top = toCrop.top + "px";\n      });\n      clearCanvas();\n      elements.canvas.addEventListener("mousedown", createHandles, false);\n    };\n\n    reader.readAsDataURL(file);\n  };\n\n  var dragFileEnter = function dragFileEnter() {\n    /*\n     * Gives feedback when the file enterd the display area.\n     */\n\n    elements.display.classList.add("hovered");\n  };\n\n  var dragFileLeave = function dragFileLeave() {\n    /*\n     * Gives feedback when the file left the display area.\n     */\n\n    elements.display.classList.remove("hovered");\n  };\n\n  var dragFileOver = function dragFileOver(event) {\n    /*\n     * Make sure the source item if copied when dropped.\n     */\n\n    event = event || window.event;\n    event.stopPropagation();\n    event.preventDefault();\n    event.dataTransfer.dropEffect = "copy";\n  };\n\n  var createHandles = function createHandles(event) {\n    if (isDrawing) {\n      var canvas = elements.canvas,\n          cbounds = canvas.getBoundingClientRect();\n      // Mouse position relative to canvas.\n      var x = event.clientX - cbounds.left,\n          y = event.clientY - cbounds.top;\n\n      handles += 1;\n\n      points.push([x, y]);\n\n      var handle = document.createElement("div");\n      elements.display.appendChild(handle);\n      handle.className = "handle";\n      handle.style.left = x + toCrop.left - handle.offsetWidth / 2 + "px";\n      handle.style.top = y + toCrop.top - handle.offsetWidth / 2 + "px";\n\n      if (handles == s) {\n        points = sortPoints(points);\n        draw(points);\n\n        // Stop drawing, now it\'s only resizing.\n        isDrawing = false;\n\n        var _handles = document.querySelectorAll(".handle");\n        labelHandles(points, _handles);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = _handles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            handle = _step2.value;\n\n            document.addEventListener("mousedown", startResizing);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  var clearCanvas = function clearCanvas() {\n    var canvas = elements.canvas,\n        context = canvas.getContext("2d");\n\n    points = [];\n    isDrawing = true;\n\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    var handles = document.querySelectorAll(".handle");\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = handles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var handle = _step3.value;\n\n        elements.display.removeChild(handle);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  };\n\n  var draw = function draw(points) {\n    /*\n     * Draws a shape based on a series of points and the overlay around it.\n     */\n\n    var canvas = elements.canvas;\n    var context = canvas.getContext("2d");\n    // Save context for clipping and clear canvas.\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.save();\n    // Draw overlay\n    context.fillStyle = "rgba(0, 0, 0, .7)";\n    context.fillRect(0, 0, canvas.width, canvas.height);\n    context.restore();\n    // Draw quadrilateral.\n    context.save();\n    context.setLineDash([5, 3]);\n    context.strokeStyle = "white";\n    context.lineWidth = 2;\n    context.beginPath();\n    context.moveTo(points[0][0], points[0][1]);\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = points.slice(1)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _point = _step4.value;\n\n        context.lineTo(_point[0], _point[1]);\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    context.closePath();\n    // Create a "hole" on the overlay inside the quadrilateral.\n    context.clip();\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    // Add stroke outside the cleared area.\n    context.stroke();\n    // Remove clipping mask.\n    context.restore();\n  };\n\n  var labelHandles = function labelHandles(points, handles) {\n    /*\n     * Adds ids to the handles after the sorted points.\n     *\n     * !IMPORTANT! The point is relative to the canvas,\n     * and the handle is relative to the display area.\n     */\n\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = handles[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var handle = _step5.value;\n\n        var hleft = parseInt(handle.style.left, 10) + handle.offsetWidth / 2,\n            htop = parseInt(handle.style.top, 10) + handle.offsetWidth / 2;\n        /* eslint-disable */\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = points.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var _ref = _step6.value;\n\n            var _ref2 = _slicedToArray(_ref, 2),\n                index = _ref2[0],\n                point = _ref2[1];\n\n            if (parseInt(point[0] + toCrop.left, 10) === hleft && parseInt(point[1] + toCrop.top, 10) === htop && handle.id === "") {\n              handle.id = "direction-" + index;\n            }\n          }\n          /* eslint-enable */\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n  };\n\n  var sortPoints = function sortPoints(points) {\n    /*\n     * Receives an array with four points and returns it\n     * sorted in a clockwise manner.\n     */\n\n    var center = findCenter(points);\n\n    return points.sort(function (a, b) {\n      var angle_a = findAngle(center, a),\n          angle_b = findAngle(center, b);\n      return angle_a > angle_b;\n    });\n  };\n\n  var findCenter = function findCenter(points) {\n    /*\n     * Find the center of an array of points.\n     */\n\n    var x = 0,\n        y = 0;\n\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = points[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var _point2 = _step7.value;\n\n        x += _point2[0];\n        y += _point2[1];\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n\n    return [x / points.length, y / points.length];\n  };\n\n  var findAngle = function findAngle(center, point) {\n    /*\n     * Find the angle of the point relative do the center of the polygon.\n     */\n\n    var dx = point[0] - center[0],\n        dy = point[1] - center[1];\n\n    return Math.atan2(dx, dy);\n  };\n\n  var startResizing = function startResizing(event) {\n    /*\n      * Gets all starting positions for the resizing action and starts it.\n      */\n\n    if (!isDrawing && event.target.className === "handle") {\n      var handle = event.target,\n          hdim = handle.offsetWidth,\n          direction = parseInt(handle.id.substr(10), 10),\n          bounds = elements.canvas.getBoundingClientRect();\n\n      document.onmousemove = function (event) {\n        var x = event.clientX,\n            y = event.clientY;\n\n        if (x < bounds.left) x = bounds.left;\n        if (x > bounds.right - hdim) x = bounds.right - hdim;\n        if (y < bounds.top) y = bounds.top;\n        if (y > bounds.bottom - hdim) y = bounds.bottom - hdim;\n\n        resize(handle, direction, x, y);\n      };\n    }\n  };\n\n  var resize = function resize(target, direction, x, y) {\n    var cbounds = elements.canvas.getBoundingClientRect(),\n        dbounds = elements.display.getBoundingClientRect(),\n        hdim = target.offsetWidth;\n\n    var displayX = x - dbounds.left,\n        displayY = y - dbounds.top,\n        canvasX = x - cbounds.left + hdim / 2,\n        canvasY = y - cbounds.top + hdim / 2;\n\n    target.style.left = displayX + "px";\n    target.style.top = displayY + "px";\n\n    points[direction] = [canvasX, canvasY];\n    draw(points);\n  };\n\n  var crop = function crop() {\n    /*\n     * Returns a promise with the base64 of the cropped area if all goes well.\n     */\n\n    return new Promise(function (resolve, reject) {\n      if (handles === s) {\n        var cropped = "";\n\n        var canvas = document.createElement("canvas"),\n            context = canvas.getContext("2d"),\n            image = new Image();\n\n        image.onload = function () {\n          canvas.width = image.width;\n          canvas.height = image.height;\n\n          var ratio = image.height / toCrop.height,\n              realPoints = [];\n\n          var _iteratorNormalCompletion8 = true;\n          var _didIteratorError8 = false;\n          var _iteratorError8 = undefined;\n\n          try {\n            for (var _iterator8 = points[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n              var _point3 = _step8.value;\n\n              realPoints.push([_point3[0] * ratio, _point3[1] * ratio]);\n            }\n\n            // Save context for clipping and clear canvas.\n          } catch (err) {\n            _didIteratorError8 = true;\n            _iteratorError8 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                _iterator8.return();\n              }\n            } finally {\n              if (_didIteratorError8) {\n                throw _iteratorError8;\n              }\n            }\n          }\n\n          context.clearRect(0, 0, canvas.width, canvas.height);\n          context.save();\n          // Draw overlay\n          context.fillStyle = "rgba(0, 0, 0, 0)";\n          context.fillRect(0, 0, canvas.width, canvas.height);\n          context.restore();\n          // Draw polygon.\n          context.save();\n          context.beginPath();\n          context.moveTo(realPoints[0][0], realPoints[0][1]);\n          var _iteratorNormalCompletion9 = true;\n          var _didIteratorError9 = false;\n          var _iteratorError9 = undefined;\n\n          try {\n            for (var _iterator9 = realPoints.slice(1)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n              var _point4 = _step9.value;\n\n              context.lineTo(_point4[0], _point4[1]);\n            }\n          } catch (err) {\n            _didIteratorError9 = true;\n            _iteratorError9 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                _iterator9.return();\n              }\n            } finally {\n              if (_didIteratorError9) {\n                throw _iteratorError9;\n              }\n            }\n          }\n\n          context.closePath();\n          // Create a "hole" on the overlay inside the polygon.\n          context.clip();\n          context.drawImage(image, 0, 0, image.width, image.height);\n          // Remove clipping mask.\n          context.restore();\n\n          cropped = canvas.toDataURL();\n\n          resolve(cropped);\n        };\n\n        image.onerror = function () {\n          reject("Error");\n        };\n\n        image.src = toCrop.base64;\n      } else {\n        reject("Not enough handles.");\n      }\n    });\n  };\n\n  var getBackgroundImageSize = function getBackgroundImageSize() {\n    /*\n     * Returns a Promise that will resolve when all the info about the \n     * background image is saved to the ~toCrop~ global object.\n     */\n\n    var base64 = elements.display.style.backgroundImage.slice(5, -2),\n        dbounds = elements.display.getBoundingClientRect();\n\n    return new Promise(function (resolve, reject) {\n      var image = new Image();\n      image.onload = function () {\n        // Check image orientation.\n        var orientation = image.width > image.height ? "horizontal" : "vertical";\n        // Get background image size.\n        var width = 0,\n            height = 0,\n            top = 0,\n            left = 0;\n        if (orientation === "horizontal") {\n          // Width of the image will be the same as the container.\n          width = dbounds.width;\n          height = image.height * dbounds.width / image.width;\n          top = (dbounds.height - height) / 2;\n        } else if (orientation === "vertical") {\n          // Height of the image will be the same as the container.\n          height = dbounds.height;\n          width = image.width * dbounds.height / image.height;\n          left = (dbounds.width - width) / 2;\n        }\n\n        toCrop = {\n          base64: base64,\n          width: width,\n          height: height,\n          left: left,\n          top: top\n        };\n\n        resolve(toCrop);\n      };\n\n      image.onerror = function () {\n        reject("Error.");\n      };\n\n      image.src = base64;\n    });\n  };\n\n  var clear = function clear() {\n    crop().then(function (base64) {\n      elements.preview.style.backgroundImage = "url(" + base64 + ")";\n    });\n    document.onmousemove = function () {};\n  };\n\n  return {\n    init: init\n  };\n}();\n\nmodule.exports = exports = IdCrop;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9saWIvanMvaWRjcm9wLmpzPzQ4N2UiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgSWRDcm9wID0gKGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBsZXQgZWxlbWVudHMgPSB7fSxcbiAgICB0b0Nyb3AgPSB7fSxcbiAgICBpc0RyYXdpbmcgPSBmYWxzZSxcbiAgICBoYW5kbGVzID0gMCxcbiAgICBwb2ludHMgPSBbXSxcbiAgICBzID0gNDtcblxuICBjb25zdCBpbml0ID0gZnVuY3Rpb24oZGlzcGxheUlkLCBwcmV2aWV3SWQsIHRvb2xiYXJJZCwgc2lkZXMpIHtcbiAgICBzID0gc2lkZXM7XG4gICAgLy8gR2VuZXJhdGUgdGhlIFVJLlxuICAgIGNyZWF0ZVVJKGRpc3BsYXlJZCwgcHJldmlld0lkLCB0b29sYmFySWQpO1xuICAgIGZha2VJbnB1dChlbGVtZW50cy51cGxvYWQsIGVsZW1lbnRzLmZha2VVcGxvYWQpO1xuICAgIC8vIEZpbGUgaW5wdXQgYnkgY2xpY2tpbmcgZXZlbnQuXG4gICAgZWxlbWVudHMudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgc3RhcnRDcm9wcGluZ0FyZWEsIGZhbHNlKTtcbiAgICAvLyBGaWxlIGlucHV0IGJ5IGRyYWdnaW5nIGV2ZW50LlxuICAgIGNvbnN0IGRyYWdnYWJsZXMgPSBbZWxlbWVudHMuZGlzcGxheSwgZWxlbWVudHMuY2FudmFzXTtcbiAgICBmb3IgKGNvbnN0IGRyYWdnYWJsZSBvZiBkcmFnZ2FibGVzKSB7XG4gICAgICBkcmFnZ2FibGUuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbnRlclwiLCBkcmFnRmlsZUVudGVyLCBmYWxzZSk7XG4gICAgICBkcmFnZ2FibGUuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIGRyYWdGaWxlT3ZlciwgZmFsc2UpO1xuICAgICAgZHJhZ2dhYmxlLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnbGVhdmVcIiwgZHJhZ0ZpbGVMZWF2ZSwgZmFsc2UpO1xuICAgICAgZHJhZ2dhYmxlLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIHN0YXJ0Q3JvcHBpbmdBcmVhLCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIENsZWFyIGV2ZW50cy5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgY2xlYXIsIGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBjcmVhdGVVSSA9IGZ1bmN0aW9uKGRpc3BsYXlJZCwgcHJldmlld0lkLCB0b29sYmFySWQpIHtcbiAgICAvKlxuICAgICAqIEluamVjdHMgSFRNTCBuZWVkZWQgZm9yIHRoZSBVSSBpbnRvIHRoZSB1c2VyIGNob3NlbiBjb250YWluZXJzLlxuICAgICAqL1xuXG4gICAgY29uc3QgZGlzcGxheUFyZWEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRpc3BsYXlJZCksXG4gICAgICBwcmV2aWV3QXJlYSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocHJldmlld0lkKSxcbiAgICAgIHRvb2xiYXJBcmVhID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0b29sYmFySWQpO1xuXG4gICAgLy8gQWRkIGNsYXNzZXMgdG8gY29udGFpbmVyc1xuICAgIGRpc3BsYXlBcmVhLmNsYXNzTGlzdC5hZGQoXCJpZHdhbGwtZGlzcGxheVwiKTtcbiAgICBwcmV2aWV3QXJlYS5jbGFzc0xpc3QuYWRkKFwiaWR3YWxsLXByZXZpZXdcIik7XG5cbiAgICBsZXQgaHRtbERpc3BsYXkgPSBcIlwiLFxuICAgICAgaHRtbFRvb2xiYXIgPSBcIlwiO1xuXG4gICAgLy8gQWN0dWFsIGNyb3BwaW5nIGNvbnRhaW5lci5cbiAgICBodG1sRGlzcGxheSArPSBcIjxjYW52YXMgaWQ9J2lkd2FsbC1jcm9wJz48L2NhbnZhcz5cIjtcbiAgICBodG1sRGlzcGxheSArPSBcIjxwPkRyb3AgZmlsZXMgaGVyZSBvciBcIjtcbiAgICAvLyBGYWtlIGJ1dHRvbiBmb3IgYmV0dGVyIHN0eWxlIGhhbmRsaW5nIG9mIHRoZSBmaWxlIGlucHV0LlxuICAgIGh0bWxEaXNwbGF5ICs9IFwiPGEgaHJlZj0nJyBpZD0naWR3YWxsLXVwbG9hZC1mYWtlJz5icm93c2UuLi48L2E+XCI7XG4gICAgaHRtbERpc3BsYXkgKz0gXCI8L3A+XCI7XG4gICAgLy8gRmlsZSBpbnB1dCBmb3IgY29udmVuaWVuY2UuXG4gICAgaHRtbFRvb2xiYXIgKz0gXCI8aW5wdXQgdHlwZT0nZmlsZScgbmFtZT0ndXBsb2FkJyBpZD0naWR3YWxsLXVwbG9hZCcgLz5cIjtcbiAgICBodG1sVG9vbGJhciArPSBcIjxwIGlkPSdpZHdhbGwtZmlsZS1uYW1lJz5ObyBmaWxlIHNlbGVjdGVkLjwvcD5cIjtcblxuICAgIHRvb2xiYXJBcmVhLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBodG1sVG9vbGJhcik7XG4gICAgZGlzcGxheUFyZWEuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIGh0bWxEaXNwbGF5KTtcblxuICAgIC8vIFBvcHVsYXRlIGVsZW1lbnRzIEpTT04sIG5vdyB0aGF0IHRoZXkgZXhpc3QuXG4gICAgZWxlbWVudHMgPSBnZXRFbGVtZW50cyhkaXNwbGF5SWQsIHByZXZpZXdJZCwgdG9vbGJhcklkKTtcbiAgfTtcblxuICBjb25zdCBnZXRFbGVtZW50cyA9IGZ1bmN0aW9uKGRpc3BsYXlJZCwgcHJldmlld0lkLCB0b29sYmFySWQpIHtcbiAgICAvKlxuICAgICAqIEdlbmVyYXRlcyBKU09OIHdpdGggYWxsIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBpbmplY3RlZCBIVE1MLlxuICAgICAqL1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIERpc3BsYXkgYXJlYS5cbiAgICAgIGRpc3BsYXk6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZGlzcGxheUlkKSxcbiAgICAgIGNhbnZhczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpZHdhbGwtY3JvcFwiKSxcbiAgICAgIGhpbnQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuaWR3YWxsLWRpc3BsYXkgcFwiKSxcbiAgICAgIC8vIFVwbG9hZCBhcmVhLlxuICAgICAgdXBsb2FkOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlkd2FsbC11cGxvYWRcIiksXG4gICAgICBmYWtlVXBsb2FkOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlkd2FsbC11cGxvYWQtZmFrZVwiKSxcbiAgICAgIGZpbGVuYW1lOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlkd2FsbC1maWxlLW5hbWVcIiksXG4gICAgICAvLyBUb29sYmFyIGFyZWEuXG4gICAgICB0b29sYmFyOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRvb2xiYXJJZCksXG4gICAgICAvLyBQcmV2aWV3IGNyb3AgYXJlYS5cbiAgICAgIHByZXZpZXc6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocHJldmlld0lkKVxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgZmFrZUlucHV0ID0gZnVuY3Rpb24oaW5wdXQsIGZha2VJbnB1dCkge1xuICAgIC8qXG4gICAgICogR2V0cyBhIGZha2UgaW5wdXQgdG8gYW5zd2VyIGFzIGlmIGl0IHdlcmUgdGhlIHJlYWwgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIE5vZGUgaW5wdXQgLSB0aGUgaW5wdXQgdG8gYmUgaGlkZGVuIGFuZCBmYWtlZC5cbiAgICAgKiBAcGFyYW0gTm9kZSBmYWtlSW5wdXQgLSB0aGUgaW5wdXQgdGhhdCB3aWxsIHNpbXVsYXRlIHRoZSBoaWRkZW4gb25lLlxuICAgICAqL1xuXG4gICAgaW5wdXQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGZha2VJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlucHV0LmNsaWNrKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3Qgc3RhcnRDcm9wcGluZ0FyZWEgPSBmdW5jdGlvbihldmVudCkge1xuICAgIC8qXG4gICAgICogRGlzcGxheXMgdGhlIGlucHV0dGVkIGZpbGUgYW5kIHN0YXJ0cyB0aGUgY3JvcHBpbmcgVUkuXG4gICAgICovXG5cbiAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgZWxlbWVudHMuZGlzcGxheS5jbGFzc0xpc3QucmVtb3ZlKFwiaG92ZXJlZFwiKTtcbiAgICBoYW5kbGVzID0gMDtcblxuICAgIC8vIEdldCB0aGUgZmlsZSBvYmplY3QgYW5kIHN0YXJ0IHRoZSByZWFkZXIuXG4gICAgY29uc3QgZmlsZSA9XG4gICAgICAgIHR5cGVvZiBldmVudC50YXJnZXQuZmlsZXMgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICA/IGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlc1swXVxuICAgICAgICAgIDogZXZlbnQudGFyZ2V0LmZpbGVzWzBdLFxuICAgICAgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuXG4gICAgZWxlbWVudHMuZmlsZW5hbWUuaW5uZXJIVE1MID0gZmlsZS5uYW1lO1xuXG4gICAgLy8gRGlzcGxheSB0aGUgaW1hZ2UsIGhpZGUgdGhlIGxhYmVsIGFuZCBzdGFydCBsaXN0ZW5pbmcgdG8gY2xpY2sgb24gY2FudmFzLlxuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgZWxlbWVudHMuZGlzcGxheS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPVxuICAgICAgICBcInVybChcIiArIGV2ZW50LnRhcmdldC5yZXN1bHQgKyBcIilcIjtcbiAgICAgIGVsZW1lbnRzLmhpbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgZWxlbWVudHMuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICAgIGdldEJhY2tncm91bmRJbWFnZVNpemUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGVsZW1lbnRzLmNhbnZhcy53aWR0aCA9IHRvQ3JvcC53aWR0aDtcbiAgICAgICAgICBlbGVtZW50cy5jYW52YXMuaGVpZ2h0ID0gdG9Dcm9wLmhlaWdodDtcbiAgICAgICAgICBlbGVtZW50cy5jYW52YXMuc3R5bGUubGVmdCA9IHRvQ3JvcC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgIGVsZW1lbnRzLmNhbnZhcy5zdHlsZS50b3AgPSB0b0Nyb3AudG9wICsgXCJweFwiO1xuICAgICAgfSk7XG4gICAgICBjbGVhckNhbnZhcygpO1xuICAgICAgZWxlbWVudHMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgY3JlYXRlSGFuZGxlcywgZmFsc2UpO1xuICAgIH07XG5cbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgfTtcblxuICBjb25zdCBkcmFnRmlsZUVudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgLypcbiAgICAgKiBHaXZlcyBmZWVkYmFjayB3aGVuIHRoZSBmaWxlIGVudGVyZCB0aGUgZGlzcGxheSBhcmVhLlxuICAgICAqL1xuXG4gICAgZWxlbWVudHMuZGlzcGxheS5jbGFzc0xpc3QuYWRkKFwiaG92ZXJlZFwiKTtcbiAgfTtcblxuICBjb25zdCBkcmFnRmlsZUxlYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgLypcbiAgICAgKiBHaXZlcyBmZWVkYmFjayB3aGVuIHRoZSBmaWxlIGxlZnQgdGhlIGRpc3BsYXkgYXJlYS5cbiAgICAgKi9cblxuICAgIGVsZW1lbnRzLmRpc3BsYXkuY2xhc3NMaXN0LnJlbW92ZShcImhvdmVyZWRcIik7XG4gIH07XG5cbiAgY29uc3QgZHJhZ0ZpbGVPdmVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvKlxuICAgICAqIE1ha2Ugc3VyZSB0aGUgc291cmNlIGl0ZW0gaWYgY29waWVkIHdoZW4gZHJvcHBlZC5cbiAgICAgKi9cblxuICAgIGV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcImNvcHlcIjtcbiAgfTtcblxuICBjb25zdCBjcmVhdGVIYW5kbGVzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoaXNEcmF3aW5nKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBlbGVtZW50cy5jYW52YXMsXG4gICAgICAgIGNib3VuZHMgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAvLyBNb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBjYW52YXMuXG4gICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WCAtIGNib3VuZHMubGVmdCxcbiAgICAgICAgeSA9IGV2ZW50LmNsaWVudFkgLSBjYm91bmRzLnRvcDtcblxuICAgICAgaGFuZGxlcyArPSAxO1xuXG4gICAgICBwb2ludHMucHVzaChbeCwgeV0pO1xuXG4gICAgICBsZXQgaGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGVsZW1lbnRzLmRpc3BsYXkuYXBwZW5kQ2hpbGQoaGFuZGxlKTtcbiAgICAgIGhhbmRsZS5jbGFzc05hbWUgPSBcImhhbmRsZVwiO1xuICAgICAgaGFuZGxlLnN0eWxlLmxlZnQgPSB4ICsgdG9Dcm9wLmxlZnQgLSBoYW5kbGUub2Zmc2V0V2lkdGggLyAyICsgXCJweFwiO1xuICAgICAgaGFuZGxlLnN0eWxlLnRvcCA9IHkgKyB0b0Nyb3AudG9wIC0gaGFuZGxlLm9mZnNldFdpZHRoIC8gMiArIFwicHhcIjtcblxuICAgICAgaWYgKGhhbmRsZXMgPT0gcykge1xuICAgICAgICBwb2ludHMgPSBzb3J0UG9pbnRzKHBvaW50cyk7XG4gICAgICAgIGRyYXcocG9pbnRzKTtcblxuICAgICAgICAvLyBTdG9wIGRyYXdpbmcsIG5vdyBpdCdzIG9ubHkgcmVzaXppbmcuXG4gICAgICAgIGlzRHJhd2luZyA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmhhbmRsZVwiKTtcbiAgICAgICAgbGFiZWxIYW5kbGVzKHBvaW50cywgaGFuZGxlcyk7XG4gICAgICAgIGZvciAoaGFuZGxlIG9mIGhhbmRsZXMpIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHN0YXJ0UmVzaXppbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNsZWFyQ2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgY2FudmFzID0gZWxlbWVudHMuY2FudmFzLFxuICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICBwb2ludHMgPSBbXTtcbiAgICBpc0RyYXdpbmcgPSB0cnVlO1xuXG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGNvbnN0IGhhbmRsZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmhhbmRsZVwiKTtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBoYW5kbGVzKSB7XG4gICAgICBlbGVtZW50cy5kaXNwbGF5LnJlbW92ZUNoaWxkKGhhbmRsZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGRyYXcgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAvKlxuICAgICAqIERyYXdzIGEgc2hhcGUgYmFzZWQgb24gYSBzZXJpZXMgb2YgcG9pbnRzIGFuZCB0aGUgb3ZlcmxheSBhcm91bmQgaXQuXG4gICAgICovXG5cbiAgICBjb25zdCBjYW52YXMgPSBlbGVtZW50cy5jYW52YXM7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgLy8gU2F2ZSBjb250ZXh0IGZvciBjbGlwcGluZyBhbmQgY2xlYXIgY2FudmFzLlxuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgLy8gRHJhdyBvdmVybGF5XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgLjcpXCI7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIC8vIERyYXcgcXVhZHJpbGF0ZXJhbC5cbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LnNldExpbmVEYXNoKFs1LCAzXSk7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDI7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSk7XG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMuc2xpY2UoMSkpIHtcbiAgICAgIGNvbnRleHQubGluZVRvKHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgLy8gQ3JlYXRlIGEgXCJob2xlXCIgb24gdGhlIG92ZXJsYXkgaW5zaWRlIHRoZSBxdWFkcmlsYXRlcmFsLlxuICAgIGNvbnRleHQuY2xpcCgpO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgLy8gQWRkIHN0cm9rZSBvdXRzaWRlIHRoZSBjbGVhcmVkIGFyZWEuXG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAvLyBSZW1vdmUgY2xpcHBpbmcgbWFzay5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfTtcblxuICBjb25zdCBsYWJlbEhhbmRsZXMgPSBmdW5jdGlvbihwb2ludHMsIGhhbmRsZXMpIHtcbiAgICAvKlxuICAgICAqIEFkZHMgaWRzIHRvIHRoZSBoYW5kbGVzIGFmdGVyIHRoZSBzb3J0ZWQgcG9pbnRzLlxuICAgICAqXG4gICAgICogIUlNUE9SVEFOVCEgVGhlIHBvaW50IGlzIHJlbGF0aXZlIHRvIHRoZSBjYW52YXMsXG4gICAgICogYW5kIHRoZSBoYW5kbGUgaXMgcmVsYXRpdmUgdG8gdGhlIGRpc3BsYXkgYXJlYS5cbiAgICAgKi9cblxuICAgIGZvciAoY29uc3QgaGFuZGxlIG9mIGhhbmRsZXMpIHtcbiAgICAgIGNvbnN0IGhsZWZ0ID0gcGFyc2VJbnQoaGFuZGxlLnN0eWxlLmxlZnQsIDEwKSArIGhhbmRsZS5vZmZzZXRXaWR0aCAvIDIsXG4gICAgICAgIGh0b3AgPSBwYXJzZUludChoYW5kbGUuc3R5bGUudG9wLCAxMCkgKyBoYW5kbGUub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgIGZvciAoW2luZGV4LCBwb2ludF0gb2YgcG9pbnRzLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcGFyc2VJbnQocG9pbnRbMF0gKyB0b0Nyb3AubGVmdCwgMTApID09PSBobGVmdCAmJlxuICAgICAgICAgIHBhcnNlSW50KHBvaW50WzFdICsgdG9Dcm9wLnRvcCwgMTApID09PSBodG9wICYmXG4gICAgICAgICAgaGFuZGxlLmlkID09PSBcIlwiXG4gICAgICAgICkge1xuICAgICAgICAgIGhhbmRsZS5pZCA9IFwiZGlyZWN0aW9uLVwiICsgaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc29ydFBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIC8qXG4gICAgICogUmVjZWl2ZXMgYW4gYXJyYXkgd2l0aCBmb3VyIHBvaW50cyBhbmQgcmV0dXJucyBpdFxuICAgICAqIHNvcnRlZCBpbiBhIGNsb2Nrd2lzZSBtYW5uZXIuXG4gICAgICovXG5cbiAgICBjb25zdCBjZW50ZXIgPSBmaW5kQ2VudGVyKHBvaW50cyk7XG5cbiAgICByZXR1cm4gcG9pbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgY29uc3QgYW5nbGVfYSA9IGZpbmRBbmdsZShjZW50ZXIsIGEpLFxuICAgICAgICBhbmdsZV9iID0gZmluZEFuZ2xlKGNlbnRlciwgYik7XG4gICAgICByZXR1cm4gYW5nbGVfYSA+IGFuZ2xlX2I7XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgZmluZENlbnRlciA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIC8qXG4gICAgICogRmluZCB0aGUgY2VudGVyIG9mIGFuIGFycmF5IG9mIHBvaW50cy5cbiAgICAgKi9cblxuICAgIGxldCB4ID0gMCxcbiAgICAgIHkgPSAwO1xuXG4gICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICAgIHggKz0gcG9pbnRbMF07XG4gICAgICB5ICs9IHBvaW50WzFdO1xuICAgIH1cblxuICAgIHJldHVybiBbeCAvIHBvaW50cy5sZW5ndGgsIHkgLyBwb2ludHMubGVuZ3RoXTtcbiAgfTtcblxuICBjb25zdCBmaW5kQW5nbGUgPSBmdW5jdGlvbihjZW50ZXIsIHBvaW50KSB7XG4gICAgLypcbiAgICAgKiBGaW5kIHRoZSBhbmdsZSBvZiB0aGUgcG9pbnQgcmVsYXRpdmUgZG8gdGhlIGNlbnRlciBvZiB0aGUgcG9seWdvbi5cbiAgICAgKi9cblxuICAgIGNvbnN0IGR4ID0gcG9pbnRbMF0gLSBjZW50ZXJbMF0sXG4gICAgICBkeSA9IHBvaW50WzFdIC0gY2VudGVyWzFdO1xuXG4gICAgcmV0dXJuIE1hdGguYXRhbjIoZHgsIGR5KTtcbiAgfTtcblxuICBjb25zdCBzdGFydFJlc2l6aW5nID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvKlxuICAgICAgKiBHZXRzIGFsbCBzdGFydGluZyBwb3NpdGlvbnMgZm9yIHRoZSByZXNpemluZyBhY3Rpb24gYW5kIHN0YXJ0cyBpdC5cbiAgICAgICovXG5cbiAgICBpZiAoIWlzRHJhd2luZyAmJiBldmVudC50YXJnZXQuY2xhc3NOYW1lID09PSBcImhhbmRsZVwiKSB7XG4gICAgICBjb25zdCBoYW5kbGUgPSBldmVudC50YXJnZXQsXG4gICAgICAgIGhkaW0gPSBoYW5kbGUub2Zmc2V0V2lkdGgsXG4gICAgICAgIGRpcmVjdGlvbiA9IHBhcnNlSW50KGhhbmRsZS5pZC5zdWJzdHIoMTApLCAxMCksXG4gICAgICAgIGJvdW5kcyA9IGVsZW1lbnRzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgZG9jdW1lbnQub25tb3VzZW1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBsZXQgeCA9IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgeSA9IGV2ZW50LmNsaWVudFk7XG5cbiAgICAgICAgaWYgKHggPCBib3VuZHMubGVmdCkgeCA9IGJvdW5kcy5sZWZ0O1xuICAgICAgICBpZiAoeCA+IGJvdW5kcy5yaWdodCAtIGhkaW0pIHggPSBib3VuZHMucmlnaHQgLSBoZGltO1xuICAgICAgICBpZiAoeSA8IGJvdW5kcy50b3ApIHkgPSBib3VuZHMudG9wO1xuICAgICAgICBpZiAoeSA+IGJvdW5kcy5ib3R0b20gLSBoZGltKSB5ID0gYm91bmRzLmJvdHRvbSAtIGhkaW07XG5cbiAgICAgICAgcmVzaXplKGhhbmRsZSwgZGlyZWN0aW9uLCB4LCB5KTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlc2l6ZSA9IGZ1bmN0aW9uKHRhcmdldCwgZGlyZWN0aW9uLCB4LCB5KSB7XG4gICAgY29uc3QgY2JvdW5kcyA9IGVsZW1lbnRzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGRib3VuZHMgPSBlbGVtZW50cy5kaXNwbGF5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgaGRpbSA9IHRhcmdldC5vZmZzZXRXaWR0aDtcblxuICAgIGNvbnN0IGRpc3BsYXlYID0geCAtIGRib3VuZHMubGVmdCxcbiAgICAgIGRpc3BsYXlZID0geSAtIGRib3VuZHMudG9wLFxuICAgICAgY2FudmFzWCA9IHggLSBjYm91bmRzLmxlZnQgKyBoZGltIC8gMixcbiAgICAgIGNhbnZhc1kgPSB5IC0gY2JvdW5kcy50b3AgKyBoZGltIC8gMjtcblxuICAgIHRhcmdldC5zdHlsZS5sZWZ0ID0gZGlzcGxheVggKyBcInB4XCI7XG4gICAgdGFyZ2V0LnN0eWxlLnRvcCA9IGRpc3BsYXlZICsgXCJweFwiO1xuXG4gICAgcG9pbnRzW2RpcmVjdGlvbl0gPSBbY2FudmFzWCwgY2FudmFzWV07XG4gICAgZHJhdyhwb2ludHMpO1xuICB9O1xuXG4gIGNvbnN0IGNyb3AgPSBmdW5jdGlvbigpIHtcbiAgICAvKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHdpdGggdGhlIGJhc2U2NCBvZiB0aGUgY3JvcHBlZCBhcmVhIGlmIGFsbCBnb2VzIHdlbGwuXG4gICAgICovXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmIChoYW5kbGVzID09PSBzKSB7XG4gICAgICAgICAgbGV0IGNyb3BwZWQgPSBcIlwiO1xuXG4gICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLFxuICAgICAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgICAgICBsZXQgcmF0aW8gPSBpbWFnZS5oZWlnaHQgLyB0b0Nyb3AuaGVpZ2h0LFxuICAgICAgICAgICAgICByZWFsUG9pbnRzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICAgICAgICAgIHJlYWxQb2ludHMucHVzaChbcG9pbnRbMF0gKiByYXRpbywgcG9pbnRbMV0gKiByYXRpb10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYXZlIGNvbnRleHQgZm9yIGNsaXBwaW5nIGFuZCBjbGVhciBjYW52YXMuXG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAvLyBEcmF3IG92ZXJsYXlcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIC8vIERyYXcgcG9seWdvbi5cbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHJlYWxQb2ludHNbMF1bMF0sIHJlYWxQb2ludHNbMF1bMV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiByZWFsUG9pbnRzLnNsaWNlKDEpKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgXCJob2xlXCIgb24gdGhlIG92ZXJsYXkgaW5zaWRlIHRoZSBwb2x5Z29uLlxuICAgICAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgY2xpcHBpbmcgbWFzay5cbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICBjcm9wcGVkID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuXG4gICAgICAgICAgICByZXNvbHZlKGNyb3BwZWQpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZWplY3QoXCJFcnJvclwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbWFnZS5zcmMgPSB0b0Nyb3AuYmFzZTY0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KFwiTm90IGVub3VnaCBoYW5kbGVzLlwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGdldEJhY2tncm91bmRJbWFnZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAvKlxuICAgICAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gYWxsIHRoZSBpbmZvIGFib3V0IHRoZSBcbiAgICAgKiBiYWNrZ3JvdW5kIGltYWdlIGlzIHNhdmVkIHRvIHRoZSB+dG9Dcm9wfiBnbG9iYWwgb2JqZWN0LlxuICAgICAqL1xuXG4gICAgY29uc3QgYmFzZTY0ID0gZWxlbWVudHMuZGlzcGxheS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2Uuc2xpY2UoNSwgLTIpLFxuICAgICAgICAgIGRib3VuZHMgPSBlbGVtZW50cy5kaXNwbGF5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBDaGVjayBpbWFnZSBvcmllbnRhdGlvbi5cbiAgICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9XG4gICAgICAgICAgICBpbWFnZS53aWR0aCA+IGltYWdlLmhlaWdodCA/IFwiaG9yaXpvbnRhbFwiIDogXCJ2ZXJ0aWNhbFwiO1xuICAgICAgICAgIC8vIEdldCBiYWNrZ3JvdW5kIGltYWdlIHNpemUuXG4gICAgICAgICAgbGV0IHdpZHRoID0gMCxcbiAgICAgICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgICAgICB0b3AgPSAwLFxuICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgLy8gV2lkdGggb2YgdGhlIGltYWdlIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIGNvbnRhaW5lci5cbiAgICAgICAgICAgIHdpZHRoID0gZGJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodCAqIGRib3VuZHMud2lkdGggLyBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgIHRvcCA9IChkYm91bmRzLmhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgLy8gSGVpZ2h0IG9mIHRoZSBpbWFnZSB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBjb250YWluZXIuXG4gICAgICAgICAgICBoZWlnaHQgPSBkYm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGggKiBkYm91bmRzLmhlaWdodCAvIGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgIGxlZnQgPSAoZGJvdW5kcy53aWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9Dcm9wID0ge1xuICAgICAgICAgICAgYmFzZTY0OiBiYXNlNjQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXNvbHZlKHRvQ3JvcCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVqZWN0KFwiRXJyb3IuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW1hZ2Uuc3JjID0gYmFzZTY0O1xuICAgIH0pOyAgICBcbiAgfTtcblxuICBjb25zdCBjbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIGNyb3AoKS50aGVuKGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgICAgICBlbGVtZW50cy5wcmV2aWV3LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IFwidXJsKFwiICsgYmFzZTY0ICsgXCIpXCI7XG4gICAgfSk7XG4gICAgZG9jdW1lbnQub25tb3VzZW1vdmUgPSBmdW5jdGlvbigpIHt9O1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgaW5pdDogaW5pdFxuICB9O1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gSWRDcm9wO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9qcy9pZGNyb3AuanMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFTQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBU0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQVhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQVVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFaQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBcUJBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUF2QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFRQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFIQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBSUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNBO0FBdEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQUE7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFRQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFYQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUxBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFzQkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQXhCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},/*!*************************!*\
	!*** ./lib/js/index.js ***!
	\*************************/
  /*! dynamic exports provided */
  /*! all exports used */
  function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(/*! ../scss/main.scss */ 2);\n\n__webpack_require__(/*! ./idcrop.js */ 0);\n\n__webpack_require__(/*! ./main.js */ 3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9saWIvanMvaW5kZXguanM/NjIwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnQgU0NTUyBmaWxlcy5cbmltcG9ydCBcIi4uL3Njc3MvbWFpbi5zY3NzXCI7XG5cbi8vIEltcG9ydCBKUy5cbmltcG9ydCBcIi4vaWRjcm9wLmpzXCI7XG5pbXBvcnQgXCIuL21haW4uanNcIjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvanMvaW5kZXguanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},/*!****************************!*\
	!*** ./lib/scss/main.scss ***!
	\****************************/
  /*! dynamic exports provided */
  /*! all exports used */
  function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9zY3NzL21haW4uc2Nzcz8yODI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvc2Nzcy9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")},/*!************************!*\
	!*** ./lib/js/main.js ***!
	\************************/
  /*! dynamic exports provided */
  /*! all exports used */
  function(module,exports,__webpack_require__){"use strict";eval('\n\nvar idcrop = __webpack_require__(/*! ./idcrop.js */ 0);\nidcrop.init("#displayContainer", "#previewContainer", "#toolbarContainer", 6);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9saWIvanMvbWFpbi5qcz8zNDc1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlkY3JvcCA9IHJlcXVpcmUoXCIuL2lkY3JvcC5qc1wiKTtcbmlkY3JvcC5pbml0KFwiI2Rpc3BsYXlDb250YWluZXJcIiwgXCIjcHJldmlld0NvbnRhaW5lclwiLCBcIiN0b29sYmFyQ29udGFpbmVyXCIsIDYpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9qcy9tYWluLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n')}]);